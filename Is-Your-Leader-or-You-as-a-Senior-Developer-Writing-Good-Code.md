# Is Your Leader or You as a Senior Developer Writing Good Code?
![Confused cartoon character holding head with question marks above](./images//confused.png)

### Index
* The Trap of “Always Cutting-Edge”
* How This Affects Junior Developers
* What Good Code Should Be
* My Simple Test for “Good Enough” Code
* How Seniors Can Write Better Code for the Team
* My Personal Story

One of the big challenges for junior developers is not just learning new tools or fixing bugs. It’s dealing with code written by senior developers that is so complex, even the seniors have trouble maintaining it.

## 1. The Trap of “Always Cutting-Edge”

Many leaders push to use the newest features, patterns, or tools. The goal often sounds good:

* stay modern,
* make the system “future-proof,”
* or show technical skill.

But sometimes this goes too far. The result is code that looks smart but is not easy to understand.

* Too many layers of abstraction make it hard to follow.
* Fancy tricks or one-liners hide the real meaning.
* Even the original author may struggle to explain it later.

In the end, this doesn’t make the project stronger. It makes it weaker.

## 2. How This Affects Junior Developers

For juniors, this type of code feels like a closed door:

* It makes them feel lost instead of curious.
* Code reviews turn into “just trust me” moments instead of learning.
* The knowledge stays in the hands of one person, raising the risk if they leave.

Instead of growing with the team, juniors may feel stuck on the outside.

## 3. What Good Code Should Be

Good code does not need to be so simple anyone could write it. Some complexity is natural. But at minimum, good code should be:

* **Readable**: a junior should be able to follow the logic.
* **Teachable**: patterns should help others learn, not push them away.
* **Maintainable**: the next developer should be able to update it without fear.

A good rule:
*Code should help juniors grow, not make them feel they don’t belong.*

## 4. My Simple Test for “Good Enough” Code

Over time, I’ve also created my own quick test to know if my code is in a good place. I ask myself three questions:

1. Is my code easy to explain to non-technical people?
2. Can a junior developer understand at least 75% of what’s going on?
3. Can I teach the concepts without raising more confusion?

If the answer is “yes” to these three, then my code is not just working, it’s working well for the team.

## 5. How Seniors Can Write Better Code for the Team

Leaders don’t just write code for themselves. They write it for the team. When code is clear and approachable, juniors grow faster and the whole team becomes stronger.

Here are some ways seniors can make that happen:

* **Write for the reader, not the writer.** Your code should explain itself. Imagine someone new joining the project, can they follow the logic without asking you?
* **Use comments and naming wisely.** Don’t write a comment for everything, but explain why something exists if it’s not obvious. And choose variable and function names that tell a story.
* **Avoid being “too clever.”** Just because you can write a one-liner or use the newest feature doesn’t mean you should. If it makes the code harder to read, it’s not worth it.
* **Guide in reviews, don’t gatekeep.** Code reviews should be a chance to teach. Instead of shutting down a junior’s idea, show them how to improve it.
* **Encourage exploration.** Let juniors play with the codebase. Give them space to try things, fail, and learn. Trust grows when they see their ideas can shape the project.
* **Introduce new tech with care.** If you bring a new tool, library, or language feature to the team, share the resources that helped you learn it. Show tutorials, articles, or examples, so others can follow your path. Also, set clear patterns and rules early. If something in the new tech could cause issues in the codebase, explain it and agree on restrictions. This avoids chaos and keeps everyone aligned.

When seniors write code with clarity, share knowledge openly, and guide the team, juniors grow, and so does the whole team.

## 6. My Personal Story

At my first job, I was given a codebase that was not only old but also very complicated. I felt lost. I even thought: Maybe I don’t belong in this career.

But I decided to do something different. Instead of only following tutorials, I started reading the code slowly to understand not just what it did but why. That’s when I realized: the problem was not me. The problem was that some code had been written without clear purpose.

When I shared this with my boss, he simply said:
“Now you understand what’s going on. It is time we do something about it.”

That line stuck with me. He wasn’t just agreeing with me, he was challenging me to take part in fixing it.

From time to time, he also called me into his office to show me code he was working on. His goal was never just to show me a new feature. Instead, he wanted me to see how code should work, and why some corrections were needed even if the current code “just worked.” For him, it was never only about making things work. It was about making them work correctly.

One day, I asked him: “Why don’t we just write code the way you do, instead of the way this legacy code is written?”

He smiled and told me: “That’s the reason I have you here. I guide you, and you will make the code evolve. You’ll add new features, but you’ll also correct, delete, and push new patterns that work best for us.”

That answer changed how I saw my role.

Later, my boss surprised me with a set of programming books, the exact ones I wanted but couldn’t afford. That moment was special. It showed me he truly believed in me. He wasn’t just saying nice things, he was giving me tools to grow.

By the time I was halfway through those books, I was already making better decisions as a developer. Code started to make sense. My confidence grew, not because the job was easier, but because someone gave me the trust and support I needed.

That trust made all the difference.
